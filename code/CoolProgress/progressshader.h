/*
Copyright see https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en
*/

static const char *vertexShaderSource_Ring_1 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Ring_1 = "#version 330 core\n"
	"#define SMOOTH(r) (mix(1.0, 0.0, smoothstep(0.9,1.0, r)))\n"
	"#define M_PI 3.1415926535897932384626433832795\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"uniform float deltaTime;\n"
	"uniform float r1;\n"
	"uniform float r2;\n"
	"float movingRing(vec2 uv, vec2 center, float r1, float r2)\n"
	"{\n"
	"	vec2 d = uv - center;\n"
	"	float r = sqrt( dot( d, d ) );\n"
	"	d = normalize(d);\n"
	"	float theta = -atan(d.y,d.x);\n"
	"	theta  = mod(-deltaTime+0.5*(1.0+theta/M_PI), 1.0);\n"
	"	//anti aliasing for the ring's head (thanks to TDM !)\n"
	"	theta -= max(theta - 1.0 + 1e-2, 0.0) * 1e2;\n"
	"	return theta*(SMOOTH(r/r2)-SMOOTH(r/r1));\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	vec2 uv = aPosFrag.xy;\n"
	"	float ring = movingRing(uv, vec2(0.0), r1, r2);\n"
	"	fragColor = vec4( 0.0 + 0.9*ring );\n"
	"}\0";

static const char *vertexShaderSource_Ring_2 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Ring_2 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"uniform float r1;\n"
	"uniform float r2;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"mat2 rotate2d(float _angle){\n"
	"	return mat2(cos(_angle),-sin(_angle),\n"
	"				sin(_angle),cos(_angle));\n"
	"}\n"
	"\n"
	"float angle(vec2 pos) {\n"
	"	// a goes from PI to -PI\n"
	"	float a = atan(pos.y, pos.x);\n"
	"\n"
	"	// divide by PI and it goes from 1 to -1\n"
	"	// add 1 and it goes from 0 to 2\n"
	"	// divide 2 and it goes 0 to 1\n"
	"	a = (1.+a/3.14159)/2.;\n"
	"\n"
	"	return a;\n"
	"}\n"
	"\n"
	"void main()\n"
	"{\n"
	"	vec2 pos = aPosFrag.xy * 0.5;\n"
	"	float antialias = 0.01;\n"
	"	// circle outline\n"
	"	float radius = r1;\n"
	"	float width = r2 - r1;\n"
	"	float l = length(pos);\n"
	"	vec4 calColor = 1.-vec4((smoothstep(width, width+antialias, abs(l-radius))));\n"
	"\n"
	"	float t0 = (deltaTime*1.8)/3.;\n"
	"	float t = fract(t0)*1.1;\n"
	"	float cycle = floor(t0);\n"
	"\n"
	"	// clip the circle by specifying two angles, a1, a2\n"
	"	float a1;\n"
	"	float a2;\n"
	"	if (t<=0.6) {\n"
	"	a1 = max(pow(1.-t-.04,3.), 0.1);\n"
	"	a2 = 1.;\n"
	"	} else {\n"
	"		a1 = 0.1;\n"
	"		a2 = max(pow(1.7-t, 3.), 0.2);\n"
	"	}\n"
	"\n"
	"	float a = angle(rotate2d(-4.*deltaTime + 1.26*cycle) *  pos); // from 0 to 1\n"
	"\n"
	"	calColor *= vec4(max(smoothstep(a,a+antialias, a1), smoothstep(a2,a2+antialias, a))); // a >= a1 || a <= a2\n"
	"	calColor = (calColor * (1.-vec4(.1, 0.6, 1., 0.)));\n"
	"	fragColor = vec4(0.0, 0.5, 1.0, calColor.x + calColor.y + calColor.z);"
	"}\0";

static const char *vertexShaderSource_Ring_3 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Ring_3 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"vec4 DARK_UI = vec4(0.0);\n"
	"vec4 BU_BLUE = vec4(.2,.4,.7, 1.0);\n"
	"vec4 BU_BLUE_END = vec4(.2,.4,.7, 0.0);\n"
	"void main()\n"
	"{\n"
	"	vec2 uv = aPosFrag.xy * 0.5;\n"
	"	vec4 c = DARK_UI;\n"
	"	float q = smoothstep(0.,1.,mod(deltaTime/15.,.1)/.1);\n"
	"	float m = clamp(length(uv)*2.5,0.,1.);\n"
	"	if (abs(length(uv)-q/5.)<.01) {\n"
	"		c=mix(BU_BLUE,BU_BLUE_END,m);\n"
	"	}\n"
	"	fragColor = c;\n"
	"}\0";

static const char *vertexShaderSource_FlashDot_1 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";


static const char *fragmentShaderSource_FlashDot_1 = "#version 330 core\n"
	"const float DOTS = 8.0;\n"
	"const vec3 COLOR = vec3(0.3, 0.6, 1.0);\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	vec2 p = aPosFrag.xy;\n"
	" 	float f = 0.0;\n"
	" 	for(float i = 1.0; i <= DOTS; i++)\n"
	" 	{\n"
	" 		float s = sin(0.7 * deltaTime + (i * 0.5) * deltaTime) * 0.2;\n"
	"		float c = cos(0.2 * deltaTime + (i * 0.5) * deltaTime) * 0.2 ;\n"
	"		f += 0.01 / abs(length(p*0.5 + vec2(c, s)));\n"
	"	}\n"
	"	vec3 color = COLOR*f;\n"
	" 	fragColor = vec4(color, color.z);\n"
	"}\0";

static const char *vertexShaderSource_FlashDot_2 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_FlashDot_2 = "#version 330 core\n"
	"#define DOTS 14\n"
	"#define DOTOFFSET 0.04\n"
	"#define SPEED 0.2\n"
	"#define POWER 3.\n"
	"#define COLTOP vec3(.3,0.6,1.)\n"
	"#define COLBTM vec3(1.,.4,.3)\n"
	"#define lerp mix\n"
	"#define pi 3.1415\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"float smin( float a, float b, float k )\n"
	"{\n"
	"	float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n"
	"	return mix( b, a, h ) - k*h*(1.0-h);\n"
	"}\n"
	"\n"
	"void main()\n"
	"{\n"
	"	vec2 uv = aPosFrag.xy * 0.5;\n"
	"\n"
	"	float d = 9999.;\n"
	"	vec3 col;\n"
	"	for (int i=0;i<DOTS;i++) {\n"
	"		float t = pow(fract(deltaTime*SPEED+(float(i)*DOTOFFSET)),POWER);\n"
	"		float s = pi*2.;\n"
	"		vec2 o = vec2(sin(t*s), cos(t*s))*.2;\n"
	"		float dist = length(uv+o)-.01;\n"
	"		if (dist<d){\n"
	"			col=lerp(COLTOP,COLBTM, cos(t*s)*.5+.5);\n"
	"		}\n"
	"		d = smin(d,dist, 0.04);\n"
	"	}\n"
	"	col = lerp(col, vec3(0.,0.,0.), smoothstep(0., 0.005, d));\n"
	"	// Output to screen\n"
	"	fragColor = vec4(col,col.x+col.y+col.z);\n"
	"}\0";

static const char *vertexShaderSource_FlashDot_3 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_FlashDot_3 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"#define t deltaTime\n"
	"#define s(a) d += 1./length(p+vec2(sin(a), cos(a)))\n"
	"\n"
	"void main()\n"
	"{\n"
	"	vec2 p = aPosFrag.xy * 2.0;\n"
	"\n"
	"	float d = 1.0;\n"
	"	float i = 0.0;\n"
	"	for (s(t);i<6.;i+=1.256)\n"
	"		s(i-t);\n"
	"\n"
	"	d = d*.75-6.;\n"
	"\n"
	"	fragColor = vec4(1.0, 1.0, 1.0, d/min(1.,fwidth(d)));\n"
	"}\0";

static const char *vertexShaderSource_FlashDot_4 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_FlashDot_4 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"mat2 rotation2d(float angle) {\n"
	"float s = sin(angle);\n"
	"float c = cos(angle);\n"
	"\n"
	"return mat2(\n"
	"	c, -s,\n"
	"	s, c\n"
	");\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	vec2 uv = aPosFrag.xy;\n"
	"\n"
	"	float x = 1e20;\n"
	"	float y = -1.0;\n"
	"	int th = 8;\n"
	"	for (int i=0;i<th;i++) {\n"
	"		float yes = float(i)/float(th);\n"
	"\n"
	"		vec2 fs = rotation2d(yes*3.1415*2.0) * uv;\n"
	"		fs = fs-vec2(0.1,0.21);\n"
	"		float test = length(fs*15.0);\n"
	"		if (test < 1.0) { y = yes; }\n"
	"		x = min(x,test);\n"
	"	}\n"
	"\n"
	"	float bgshade = 0.1;\n"
	"	y = 1.0-y;\n"
	"	y += 0.99;\n"
	"\n"
	"	float flippy = mix(bgshade*0.9+0.1,1.0,fract(y-deltaTime));\n"
	"	float pxw = 0.45/1.0;\n"
	"	if (y >= -1.0) { flippy = mix(flippy,bgshade,smoothstep(1.0-pxw,1.0,x)); }\n"
	"	else { flippy = bgshade; }\n"
	"\n"
	"	fragColor = vec4(flippy);\n"
	"}\0";

static const char *vertexShaderSource_WaterWave_1 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_WaterWave_1 = "#version 330 core\n"
	"#define PI 3.14\n"
	"#define step(b, a) smoothstep(a, a - (fwidth(b) * 2.0), b)\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"const vec4 iMouse = vec4(0.5, 0.5, 0.5, 0.0);\n"
	"void main()\n"
	"{\n"
	"	vec3 r=vec3(1.0, 1.0, 1.0);\n"
	"	vec2 uv=aPosFrag.xy * 2.0;\n"
	"\n"
	"	float sdf=length(uv);\n"
	"	float c=step(sdf,.85);\n"
	"	float vB=smoothstep(.1,.9,sin(aPosFrag.x+(PI*.5))-.3);\n"
	"	float vBA=vB*sin(deltaTime*4.)*.1;\n"
	"	float fW=(sin(((deltaTime*2.)+uv.x)*2.)*.05)+vBA;\n"
	"	float bW=(sin(((deltaTime*-2.)+uv.x)*2.+PI)*.05)-vBA;\n"
	"	float fA=(sin(deltaTime*4.)*.05)*vB;\n"
	"	float fV=mix(-.2,((iMouse.y/r.y)-.5)*2.,step(0.,iMouse.w));\n"
	"	float fP=fV+(sin((deltaTime)*PI)*.1);\n"
	"\n"
	"	float fF=step(uv.y,(fA+fW)+fP)*c;\n"
	"	float bF=step(uv.y,(-fA+bW)+fP)*c;\n"
	"\n"
	"	float transparent =\n"
	"		(step(sdf,1.)-step(sdf,1.))+\n"
	"		(fF+(clamp(bF-fF,0.,1.)*.8))+\n"
	"		clamp(pow((sdf+.01)*\n"
	"		((1.-(fF+bF))*c),5.),0.,1.);\n"
	"	fragColor = vec4(1.0, 1.0, 0.0, transparent);\n"
	"}\0";

static const char *vertexShaderSource_Rect_1 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Rect_1 = "#version 330 core\n"
	"precision mediump float;\n"
	"#define PI 3.14159265359\n"
	"#define QPI 0.78539816339\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"\n"
	"float rect(in vec2 uv, in float r, in vec2 offset){\n"
	"	uv += offset;\n"
	"	float b = .01;\n"
	"	return smoothstep(uv.x - r - b, uv.x - r + b, uv.y) * smoothstep(uv.x + r + b, uv.x + r - b, uv.y)\n"
	"			* smoothstep(-uv.x - r - b, -uv.x - r + b, uv.y) * smoothstep(-uv.x + r + b, -uv.x + r - b, uv.y);\n"
	"}\n"
	"\n"
	"vec2 calcPoint(in float ang){\n"
	"	vec2 ppp = vec2(cos(ang), .5 * sin(ang * 2.));\n"
	"	return vec2(pow(ppp.x, 2.) * sign(ppp.x), ppp.y);\n"
	"}\n"
	"\n"
	"void main()\n"
	"{\n"
	"	vec2 st = aPosFrag.xy * 3.0;\n"
	"	float bg;\n"
	"	{\n"
	"		vec2 uv = abs(st);\n"
	"		uv -= vec2(.5, 0.);\n"
	"		float ang = -QPI;\n"
	"		uv *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n"
	"		uv += vec2(.5, 0.);\n"
	"		float r = distance(uv, vec2(.5, 0.));\n"
	"		float a = mod(atan(uv.y, uv.x - .5), PI/2.) - QPI;\n"
	"		vec2 p = vec2(r * cos(a), r * sin(a));\n"
	"		bg = rect(p, .475, vec2(-.5, 0.));\n"
	"	}\n"
	"\n"
	"	float time = deltaTime * 4.;\n"
	"	float modAng = mod(time, QPI);\n"
	"	float ang = time - modAng;\n"
	"	vec2 emptyPoints[2]; emptyPoints[0] = calcPoint(ang); emptyPoints[1] = calcPoint(ang - QPI);\n"
	"\n"
	"	bg -= rect(st, .475, -emptyPoints[0]);\n"
	"	bg = clamp(bg, 0., 1.);\n"
	"	bg -= rect(st, .475, -emptyPoints[1]);\n"
	"	bg = clamp(bg, 0., 1.);\n"
	"	bg += rect(st, .475, -mix(emptyPoints[0], emptyPoints[1], modAng/QPI));\n"
	"\n"
	"	fragColor = vec4(0.0, 1.0, 1.0, bg);\n"
	"}\0";

static const char *vertexShaderSource_Rect_2 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Rect_2 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"float N21(vec2 p) {\n"
	"	p = fract(p * vec2(233.34, 851.73));\n"
	"	p += dot(p, p + 23.45);\n"
	"	return fract(p.x * p.y);\n"
	"}\n"
	"\n"
	"float inRect(vec2 pos, vec2 topLeft, vec2 rightBottom) {\n"
	"	return step(topLeft.x, pos.x) * step(rightBottom.y, pos.y) * step(-rightBottom.x, -pos.x) * step(-topLeft.y, -pos.y);\n"
	"}\n"
	"\n"
	"float inBetween(float x, float a, float b) {\n"
	"	return step(a, x) * step(-b, -x);\n"
	"}\n"
	"\n"
	"float boxLayer(float depth, vec2 uv, float size, float pos) {\n"
	"	const float fullDepth = 4.0;\n"
	"	float boxHalfSize = size * 0.5;\n"
	"	vec2 boxCenter = vec2(fullDepth * pos, (1.0 - boxHalfSize) * sin(deltaTime * 10.0 * (0.3 + 0.7 * N21(vec2(depth, size))) ));\n"
	"	return inRect(uv, boxCenter + vec2(-boxHalfSize, boxHalfSize), boxCenter + vec2(boxHalfSize, -boxHalfSize))\n"
	"	* inRect(uv, vec2(0.0, 1.0), vec2(3.99, -1.0)) * mix(1.0, 0.0, pos);\n"
	"}\n"
	"\n"
	"void main()\n"
	"{\n"
	"	// Normalized pixel coordinates (from 0 to 1)\n"
	"	vec2 uv = (aPosFrag.xy + 1.0) * 0.5;\n"
	"\n"
	"	float sWidth = 1.0;\n"
	"	const float barWidthRatio = 0.8;\n"
	"	float inv_barWidth = 1.0 / (barWidthRatio * sWidth);\n"
	"	float barHeight = 0.06;\n"
	"	float twice_inv_barHeight = 2.0 / barHeight;\n"
	"	uv.x = uv.x * sWidth;\n"
	"\n"
	"	mat3 T_bar2s = mat3(\n"
	"		vec3(inv_barWidth, 0.0, 0.0),\n"
	"		vec3(0.0, inv_barWidth, 0.0),\n"
	"		vec3((1.0 - sWidth * inv_barWidth) * 0.5, -0.5 * inv_barWidth, 1.0)\n"
	"   );\n"
	"\n"
	"	vec2 uv_bar = (T_bar2s * vec3(uv.xy, 1.0)).xy;\n"
	"	float isInBaseRect = inRect(uv_bar, vec2(0.0, 0.5 * barHeight), vec2(1.0, -0.5 * barHeight));\n"
	"	float isInActiveRect = inRect(uv_bar, vec2(0.0, 0.5 * barHeight), vec2(fract(deltaTime * 0.1), -0.5 * barHeight));\n"
	"	vec3 baseColor = vec3(0.12941, 0.13725, 0.17647);\n"
	"	vec3 activeColor = mix(vec3(0.2, 0.35294, 0.91373), vec3(0.43529, 0.43529, 0.96078), uv_bar.x);\n"
	"	vec3 color = vec3(0.0, 0.0, 0.0);\n"
	"	color = mix(color, baseColor, isInBaseRect);\n"
	"	color = mix(color, activeColor, isInActiveRect);\n"
	"\n"
	"	mat3 T_top2bar = mat3(\n"
	"		vec3(twice_inv_barHeight, 0.0, 0.0),\n"
	"		vec3(0.0, twice_inv_barHeight, 0.0),\n"
	"		vec3(-twice_inv_barHeight * fract(deltaTime * 0.1), 0.0, 1.0)\n"
	"	);\n"
	"\n"
	"	vec2 topCord = (T_top2bar * vec3(uv_bar, 1.0)).xy;\n"
	"\n"
	"	float sizes[8];\n"
	"\n"
	"	sizes[0] =  0.64443028954883467;\n"
	"	sizes[1] =  0.5305055282034009;\n"
	"	sizes[2] =  0.563223756594665;\n"
	"	sizes[3] =  0.7904855321774765;\n"
	"	sizes[4] =  0.58575556655444496;\n"
	"	sizes[5] =  0.3690261013697286;\n"
	"	sizes[6] =  0.40226518516562614;\n"
	"	sizes[7] =  0.935630139708542;\n"
	"\n"
	"	float inBoxes = 0.0;\n"
	"	inBoxes += boxLayer(0.0, topCord, sizes[0], fract(0.0 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.125, topCord, sizes[1], fract(0.125 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.25, topCord, sizes[2], fract(0.25 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.375, topCord, sizes[3], fract(0.375 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.5, topCord, sizes[4], fract(0.5 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.625, topCord, sizes[5], fract(0.625 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.75, topCord, sizes[6], fract(0.75 + deltaTime * 0.6));\n"
	"	inBoxes += boxLayer(0.875, topCord, sizes[7], fract(0.875 + deltaTime * 0.6));\n"
	"\n"
	"	color = mix(color, activeColor, clamp(inBoxes, 0.0, 1.0) * inBetween(uv_bar.x, 0.0, 1.0) );\n"
	"\n"
	"	// Output to screen\n"
	"	fragColor = vec4(color, color.x + color.y + color.z);\n"
	"}\0";

static const char *vertexShaderSource_Rect_3 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Rect_3 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"#define PI 3.14159\n"
	"#define r(uv,lg) ( length(uv) / norm(lg))\n"
	"#define norm(v) ( (v) / 1.0 )\n"
	"#define animate(t) ( 0.3*sin(t)*step(-PI, -mod(t,2.*PI)) )\n"
	"\n"
	"float sdBox( in vec2 p, in vec2 b ) {    //iq\n"
	"	p = p * 0.5-vec2(.0,.07);\n"
	"	vec2 d = abs(p)-b;\n"
	"	return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - .3;\n"
	"}\n"
	"float getcoef(float theta) {\n"
	"	theta /= 2.*PI;\n"
	"	return theta*smoothstep(1.,.99,theta);    //antialiasing\n"
	"}\n"
	"float pointsloading(vec2 uv) {\n"
	"	float value = smoothstep( .1, .08, r(uv - norm( vec2(.0, animate(5.*deltaTime)) ), 1.5) )\n"
	"				+ smoothstep( .1, .08, r(uv - norm( vec2(0.5, animate(5.*deltaTime-.6)) ), 1.5) )\n"
	"				+ smoothstep( .1, .08, r(uv - norm( vec2(-0.5, animate(5.*deltaTime+.6)) ), 1.5) );\n"
	"	return value;\n"
	"}\n"
	"\n"
	"void main()\n"
	"{\n"
	"	vec2 uv = aPosFrag.xy * 2.0;\n"
	"	float angle = atan(uv.y, uv.x);\n"
	"	angle = mod(angle + PI + 5.*deltaTime, 2.*PI);\n"
	"\n"
	"	vec3 color = vec3(0.);\n"
	"	float shape = smoothstep( .01, .0, sdBox( uv, vec2(.12,.0) ) ) * .7 * (1. - pointsloading(uv));\n"
	"	fragColor = vec4(vec3(0.7, 0.7, 0.7), 1.5 * shape);\n"
	"}\0";

static const char *vertexShaderSource_Polygon_1 = "#version 330 core\n"
	"layout (location = 0) in vec3 aPos;\n"
	"out vec3 aPosFrag;\n"
	"void main()\n"
	"{\n"
	"	aPosFrag = aPos;\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";

static const char *fragmentShaderSource_Polygon_1 = "#version 330 core\n"
	"uniform float deltaTime;\n"
	"out vec4 fragColor;\n"
	"in vec3 aPosFrag;\n"
	"const float pi = 3.14159265359;\n"
	"const float triangleScale = 0.816497161855865; // ratio of edge length and height\n"
	"const vec3 orange = vec3(0.937, 0.435, 0.0);\n"
	"\n"
	"float rand(vec2 co){\n"
	"	return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n"
	"}\n"
	"\n"
	"vec4 getTriangleCoords(vec2 uv) {\n"
	"	uv.y /= triangleScale;\n"
	"	uv.x -= uv.y / 2.0;\n"
	"	vec2 center = floor(uv);\n"
	"	vec2 local = fract(uv);\n"
	"\n"
	"	center.x += center.y / 2.0;\n"
	"	center.y *= triangleScale;\n"
	"\n"
	"	if (local.x + local.y > 1.0) {\n"
	"		local.x -= 1.0 - local.y;\n"
	"		local.y = 1.0 - local.y;\n"
	"		center.y += 0.586;\n"
	"		center.x += 1.0;\n"
	"	} else {\n"
	"		center.y += 0.287;\n"
	"		center.x += 0.5;\n"
	"	}\n"
	"\n"
	"	return vec4(center, local);\n"
	"}\n"
	"\n"
	"vec4 getLoader(vec4 triangle) {\n"
	"	if (length(triangle.xy) > 1.6) {\n"
	"		return vec4(0.0);\n"
	"	}\n"
	"\n"
	"	float angle = atan(triangle.x, triangle.y);\n"
	"	float seed = rand(triangle.xy);\n"
	"	float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) * 15.0;\n"
	"	float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;\n"
	"\n"
	"	return vec4(mix(orange, vec3(1.0), glow * 0.07), pow(0.5 + 0.5 * sin(angle - deltaTime * 6.0 + seed), 2.0));\n"
	"}\n"
	"\n"
	"float getBackground(vec4 triangle) {\n"
	"	float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) - 0.05;\n"
	"\n"
	"	if (triangle.y > 1.9 || triangle.y < -2.4 || dst < 0.0) {\n"
	"		return 0.0;\n"
	"	}\n"
	"\n"
	"	float value = pow(0.5 + 0.5 * cos(-abs(triangle.x) * 0.4 + rand(triangle.xy) * 2.0 + deltaTime * 4.0), 2.0) * 0.08;\n"
	"	return value * (dst > 0.05 ? 0.65 : 1.0);\n"
	"}\n"
	"\n"
	"vec3 getColor(vec2 uv) {\n"
	"	uv *= 1.0;\n"
	"\n"
	"	vec3 background = vec3(getBackground(getTriangleCoords(uv * 6.0 - vec2(0.5, 0.3))));\n"
	"	vec4 loader = getLoader(getTriangleCoords(uv * 11.0));\n"
	"\n"
	"	vec3 color = mix(background, loader.rgb, loader.a);\n"
	"	return color;\n"
	"}\n"
	"\n"
	"void main() {\n"
	"	vec2 uv = aPosFrag.xy * 0.5;\n"
	"	fragColor = vec4(1.0 * (getColor(uv)), getColor(uv));\n"
	"}\0";